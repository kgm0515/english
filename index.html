<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>English Learn</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- è¯æ±‡æ•°æ® -->
    <script src="./api/middle-school-vocabulary.js"></script>
  </head>
  <body>
    <div
      id="app"
      class="min-h-screen bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 py-8 relative"
    >
      <!-- èƒŒæ™¯è£…é¥° -->
      <div class="absolute inset-0 overflow-hidden pointer-events-none h-full">
        <div
          class="absolute -top-40 -right-40 w-80 h-80 bg-purple-300 rounded-full mix-blend-multiply filter blur-xl opacity-25 animate-blob"
        ></div>
        <div
          class="absolute -bottom-40 -left-40 w-80 h-80 bg-indigo-300 rounded-full mix-blend-multiply filter blur-xl opacity-25 animate-blob animation-delay-2000"
        ></div>
        <div
          class="absolute top-40 right-1/2 w-96 h-96 bg-pink-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-1000"
        ></div>
        <div
          class="absolute -top-20 left-1/4 w-72 h-72 bg-cyan-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-3000"
        ></div>
      </div>

      <!-- æ ‡é¢˜åŒºåŸŸ - å¸é¡¶ -->
      <div
        class="sticky top-0 z-20 pt-4 pb-4 transition-all duration-300"
        :class="isSticky ? 'backdrop-blur-lg bg-white/30 shadow-lg border-b border-slate-200/50 ' : ''"
      >
        <div class="container mx-auto px-4">
          <div class="flex items-center justify-between flex-wrap gap-3">
            <h1
              class="text-xl sm:text-2xl font-bold bg-gradient-to-r from-indigo-600 to-blue-600 bg-clip-text text-transparent"
            >
              è‹±è¯­å•è¯å­¦ä¹ 
            </h1>
            <!-- è¯æ±‡è¡¨é€‰æ‹©å™¨ -->
            <select
              v-model="currentVocabularySet"
              @change="switchVocabularySet()"
              class="py-2 pl-3 pr-9 bg-white rounded-lg text-sm border border-slate-200 hover:border-indigo-300 hover:shadow-sm transition-all focus:outline-none focus:ring-2 focus:ring-indigo-400/50 text-slate-700 shadow-sm flex-shrink-0"
            >
              <option
                v-for="set in vocabularySets"
                :key="set.value"
                :value="set.value"
                class="text-gray-900"
              >
                {{ set.label }}
              </option>
            </select>
          </div>
        </div>
      </div>

      <div class="container mx-auto px-4 relative z-10">
        <!-- ç­›é€‰æŒ‰é’®ç»„ - ä¸å¸é¡¶ -->
        <div class="mb-6 flex justify-end">
          <div
            class="flex items-center overflow-x-auto bg-white shadow-md hover:shadow-lg hover:border-indigo-300 transition-all scrollbar-hide"
          >
            <!-- <button
              @click="filterType = 'all'"
              class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium transition-all"
              :class="filterType === 'all' ? 'bg-white/25 text-white' : 'hover:bg-white/15'"
            >
              <span class="w-1.5 h-1.5 rounded-full bg-white/60"></span>
              å…¨éƒ¨ {{ wordList.length }}
            </button> -->
            <button
              @click="filterType = 'not-learned'"
              class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium transition-all text-slate-600"
              :class="filterType === 'not-learned' ? 'bg-gradient-to-r from-red-50 to-pink-50 border-l-2 border-red-400' : 'hover:bg-red-50'"
            >
              <span class="w-2 h-2 rounded-full bg-red-500 shadow-sm"></span>
              ä¸ä¼šï¼š{{ notLearnedCount }}
            </button>
            <button
              @click="filterType = 'vague'"
              class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium transition-all text-slate-600"
              :class="filterType === 'vague' ? 'bg-gradient-to-r from-amber-50 to-orange-50 border-l-2 border-amber-400' : 'hover:bg-amber-50'"
            >
              <span class="w-2 h-2 rounded-full bg-amber-500 shadow-sm"></span>
              æ¨¡ç³Šï¼š{{ vagueCount }}
            </button>
            <button
              @click="filterType = 'mastered'"
              class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium transition-all text-slate-600"
              :class="filterType === 'mastered' ? 'bg-gradient-to-r from-emerald-50 to-green-50 border-l-2 border-emerald-400' : 'hover:bg-emerald-50'"
            >
              <span
                class="w-2 h-2 rounded-full bg-emerald-500 shadow-sm"
              ></span>
              æŒæ¡ï¼š{{ masteredCount }}
            </button>
          </div>
        </div>

        <!-- å•è¯å¡ç‰‡åˆ—è¡¨ -->
        <div class="max-w-5xl mx-auto">
          <div class="space-y-3">
            <!-- ç©ºçŠ¶æ€ -->
            <div
              v-if="currentPageWords.length === 0"
              class="bg-gradient-to-br from-white to-indigo-50 bg-opacity-20 rounded-xl px-8 py-16 text-center border-2 border-indigo-200 shadow-md"
            >
              <div class="text-5xl mb-4">ğŸ“–</div>
              <h3
                class="text-xl font-semibold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent mb-2"
              >
                æš‚æ— å•è¯
              </h3>
              <p class="text-slate-500">å½“å‰ç­›é€‰æ¡ä»¶ä¸‹æ²¡æœ‰æ‰¾åˆ°å•è¯</p>
            </div>

            <!-- å½“å‰é¡µçš„å•è¯å¡ç‰‡ -->
            <div
              v-for="(word, index) in currentPageWords"
              :key="word.id || index"
              @click="playWord(word.word)"
              class="bg-white rounded-xl px-4 sm:px-6 py-4 transition-all flex flex-col sm:flex-row sm:items-center gap-4 sm:gap-6 border-2 border-transparent hover:border-indigo-100 hover:shadow-xl shadow-sm"
            >
              <!-- å•è¯å¡ç‰‡å·¦ä¾§ -->
              <div class="flex-1 w-full">
                <div class="flex items-start sm:items-center gap-2 sm:gap-4">
                  <div class="flex-1 min-w-0">
                    <div class="space-y-1.5">
                      <div class="flex items-center gap-2 sm:gap-3 flex-wrap">
                        <!-- æ’­æ”¾åŒºåŸŸ -->
                        <button
                          @click.stop="playWord(word.word)"
                          class="flex items-center gap-1.5 sm:gap-2 group transition-all"
                          title="ç‚¹å‡»æ’­æ”¾å‘éŸ³"
                        >
                          <h2
                            class="text-base sm:text-lg font-semibold transition-colors"
                            :class="playingWord === word.word ? 'text-indigo-600' : 'text-gray-900 group-hover:text-indigo-600'"
                          >
                            {{ word.word }}
                          </h2>
                          <!-- æ’­æ”¾å›¾æ ‡ -->
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                            class="w-3.5 h-3.5 sm:w-4 sm:h-4 transition-all group-hover:scale-110"
                            :class="playingWord === word.word ? 'text-indigo-600' : 'text-gray-400 group-hover:text-indigo-500'"
                          >
                            <path
                              d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"
                            />
                          </svg>
                        </button>
                        <span
                          v-if="word.pronunciation"
                          class="text-xs sm:text-sm text-indigo-700 font-mono bg-gradient-to-r from-indigo-50 to-purple-50 px-1.5 sm:px-2 py-0.5 rounded border border-indigo-100"
                        >
                          /{{ word.pronunciation }}/
                        </span>
                        <!-- è¯æ€§æ ‡ç­¾ -->
                        <span
                          v-if="word.partOfSpeech"
                          class="text-xs font-bold px-2 py-0.5 rounded-md shadow-sm"
                          :class="{
                            'bg-blue-100 text-blue-700': word.partOfSpeech.includes('n.'),
                            'bg-green-100 text-green-700': word.partOfSpeech.includes('v.'),
                            'bg-purple-100 text-purple-700': word.partOfSpeech.includes('adj.'),
                            'bg-pink-100 text-pink-700': word.partOfSpeech.includes('adv.'),
                            'bg-amber-100 text-amber-700': word.partOfSpeech.includes('prep.'),
                            'bg-cyan-100 text-cyan-700': word.partOfSpeech.includes('pron.'),
                            'bg-indigo-100 text-indigo-700': word.partOfSpeech.includes('conj.'),
                            'bg-orange-100 text-orange-700': word.partOfSpeech.includes('art.'),
                            'bg-gray-100 text-gray-700': true
                          }"
                        >
                          {{ word.partOfSpeech }}
                        </span>
                        <span
                          v-if="word.meaning"
                          class="text-xs sm:text-sm text-slate-700 font-medium"
                        >
                          {{ word.meaning }}
                        </span>
                      </div>
                      <!-- ä¾‹å¥ -->
                      <div
                        v-if="word.example || word.exampleTranslation"
                        class="flex items-center gap-2 flex-wrap"
                      >
                        <p
                          v-if="word.example"
                          @click.stop="playWord(word.example)"
                          class="text-xs sm:text-sm text-indigo-600 italic bg-indigo-50 rounded-md px-2.5 sm:px-3 py-1 sm:py-1.5 border-l-4 border-indigo-300 hover:bg-indigo-100 transition-colors cursor-pointer"
                        >
                          {{ word.example }}
                        </p>
                        <p
                          v-if="word.exampleTranslation"
                          class="text-xs sm:text-sm text-slate-600"
                        >
                          {{ word.exampleTranslation }}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- é€‰é¡¹æŒ‰é’®ç»„ -->
              <div
                class="flex gap-0 w-full sm:w-auto shrink-0 rounded overflow-hidden border-2 border-indigo-100 bg-white"
                @click.stop
              >
                <label
                  v-for="(level, i) in levels"
                  :key="level.value"
                  class="cursor-pointer flex-1 sm:flex-initial relative"
                >
                  <input
                    type="radio"
                    :name="`word-${word.id}`"
                    :value="level.value"
                    :checked="checkMastery(word.id, level.value)"
                    @change="updateWordMastery(word.id, level.value)"
                    class="peer sr-only"
                  />
                  <div
                    :class="[
                      'flex items-center justify-center px-2 sm:px-4 h-8 sm:h-9 text-xs font-medium relative',
                      level.class
                    ]"
                  >
                    <span
                      v-if="i > 0"
                      class="absolute left-0 top-1/2 -translate-y-1/2 h-3/4 w-px bg-indigo-200"
                    ></span>
                    {{ level.label }}
                  </div>
                </label>
              </div>
            </div>
          </div>

          <!-- åˆ†é¡µæ§ä»¶ -->
          <div class="flex justify-center items-center gap-2 mt-10 mb-6">
            <button
              @click="goToPage(currentPage - 1)"
              :disabled="currentPage === 1"
              class="px-3 sm:px-4 py-2 rounded-lg bg-white text-slate-700 text-sm font-medium hover:bg-indigo-50 hover:border-indigo-300 transition-all disabled:opacity-30 disabled:cursor-not-allowed border border-slate-200 shadow-sm hover:shadow-md"
            >
              <span class="hidden sm:inline">ä¸Šä¸€é¡µ</span>
              <span class="sm:hidden">prev</span>
            </button>

            <div class="flex gap-1 hidden sm:flex">
              <button
                v-for="page in visiblePages"
                :key="page"
                @click="goToPage(page)"
                :class="[
                  'w-9 h-9 rounded-lg text-sm font-medium transition-all',
                  page === currentPage
                    ? 'bg-gradient-to-br from-indigo-600 to-purple-600 text-white shadow-lg hover:shadow-xl scale-105'
                    : 'bg-white text-slate-700 hover:bg-gradient-to-br hover:from-indigo-50 hover:to-purple-50 border border-slate-200 shadow-sm hover:shadow-md hover:border-indigo-300'
                ]"
              >
                {{ page }}
              </button>
            </div>

            <button
              @click="goToPage(currentPage + 1)"
              :disabled="currentPage === totalPages"
              class="px-3 sm:px-4 py-2 rounded-lg bg-white text-slate-700 text-sm font-medium hover:bg-indigo-50 hover:border-indigo-300 transition-all disabled:opacity-30 disabled:cursor-not-allowed border border-slate-200 shadow-sm hover:shadow-md"
            >
              <span class="hidden sm:inline">ä¸‹ä¸€é¡µ</span>
              <span class="sm:hidden">next</span>
            </button>
          </div>

          <!-- åˆ†é¡µä¿¡æ¯ -->
          <div
            class="text-center text-slate-600 text-xs sm:text-sm font-medium"
          >
            ç¬¬ {{ currentPage }} / {{ totalPages }} é¡µ Â· å…± {{ wordList.length
            }} ä¸ªå•è¯
          </div>
        </div>
      </div>

      <!-- è‡ªå®šä¹‰æ ·å¼ -->
      <style>
        @keyframes blob {
          0% {
            transform: translate(0px, 0px) scale(1);
          }
          33% {
            transform: translate(30px, -50px) scale(1.1);
          }
          66% {
            transform: translate(-20px, 20px) scale(0.9);
          }
          100% {
            transform: translate(0px, 0px) scale(1);
          }
        }
        .animate-blob {
          animation: blob 7s infinite;
          will-change: transform;
        }
        .animation-delay-2000 {
          animation-delay: 2s;
        }
        .animation-delay-3000 {
          animation-delay: 3s;
        }

        /* è‡ªå®šä¹‰selectä¸‹æ‹‰æ¡†ç®­å¤´ */
        select {
          appearance: none;
          background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
          background-position: right 10px center;
          background-repeat: no-repeat;
          background-size: 1.25em 1.25em;
        }

        /* æ€§èƒ½ä¼˜åŒ–ï¼šç¡¬ä»¶åŠ é€Ÿ */
        .transition-all,
        .group,
        button,
        select {
          transform: translateZ(0);
          backface-visibility: hidden;
          perspective: 1000px;
        }

        /* ä¼˜åŒ–åŠ¨ç”»æ€§èƒ½ */
        @media (prefers-reduced-motion: reduce) {
          .animate-blob {
            animation: none;
          }
        }

        /* éšè—æ»šåŠ¨æ¡ */
        .scrollbar-hide {
          -ms-overflow-style: none; /* IE å’Œ Edge */
          scrollbar-width: none; /* Firefox */
        }
        .scrollbar-hide::-webkit-scrollbar {
          display: none; /* Chrome, Safari, Opera */
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        .overflow-y-auto::-webkit-scrollbar {
          width: 8px;
        }
        .overflow-y-auto::-webkit-scrollbar-track {
          background: rgba(255, 255, 255, 0.1);
          border-radius: 10px;
        }
        .overflow-y-auto::-webkit-scrollbar-thumb {
          background: linear-gradient(to bottom, #8b5cf6, #ec4899);
          border-radius: 10px;
        }
        .overflow-y-auto::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(to bottom, #7c3aed, #db2777);
        }
      </style>
    </div>

    <script>
      const { createApp } = Vue;

      // ==================== é…ç½®å¸¸é‡ ====================
      const CONFIG = {
        WORDS_PER_PAGE: 20, // æ¯é¡µæ˜¾ç¤ºçš„å•è¯æ•°é‡
        MAX_VISIBLE_PAGES: 5, // æœ€å¤šæ˜¾ç¤ºçš„é¡µç æ•°é‡
      };

      // è¯æ±‡è¡¨é…ç½®
      const VOCABULARY_SETS = [
        {
          label: "ğŸ“š åˆä¸­è¯æ±‡",
          value: "middle-school",
          dataVar: "middleSchoolVocabulary", // å¯¹åº”çš„æ•°æ®å˜é‡å
        },
        {
          label: "ğŸ“– é«˜ä¸­è¯æ±‡",
          value: "high-school",
          dataVar: "highSchoolVocabulary", // åç»­æ·»åŠ 
        },
        {
          label: "ğŸ“ å¤§å­¦è¯æ±‡",
          value: "college",
          dataVar: "collegeVocabulary", // åç»­æ·»åŠ 
        },
        {
          label: "ğŸ“ è€ƒç ”è¯æ±‡",
          value: "graduate",
          dataVar: "graduateVocabulary", // åç»­æ·»åŠ 
        },
      ];

      createApp({
        data() {
          return {
            wordList: [], // å•è¯åˆ—è¡¨
            loading: true, // åŠ è½½çŠ¶æ€
            currentPage: 1, // å½“å‰é¡µç 
            wordsPerPage: CONFIG.WORDS_PER_PAGE,
            filterType: "not-learned", // ç­›é€‰ç±»å‹ï¼ˆé»˜è®¤æ˜¾ç¤º"ä¸ä¼š"ï¼‰
            wordMastery: {}, // å­˜å‚¨æ¯ä¸ªå•è¯çš„æŒæ¡ç¨‹åº¦
            currentVocabularySet: "middle-school", // å½“å‰è¯æ±‡è¡¨
            vocabularySets: VOCABULARY_SETS, // è¯æ±‡è¡¨åˆ—è¡¨
            playingWord: null, // å½“å‰æ­£åœ¨æ’­æ”¾çš„å•è¯
            wordQueue: [], // æ’­æ”¾é˜Ÿåˆ—
            isSticky: false, // æ˜¯å¦å¤„äºå¸é¡¶çŠ¶æ€
            // æŒæ¡ç¨‹åº¦é€‰é¡¹é…ç½®
            levels: [
              {
                label: "ä¸ä¼š",
                value: 0,
                class:
                  "text-red-600 hover:bg-red-50 peer-checked:bg-red-100 peer-checked:text-red-700",
              },
              {
                label: "æ¨¡ç³Š",
                value: 50,
                class:
                  "text-amber-600 hover:bg-amber-50 peer-checked:bg-amber-100 peer-checked:text-amber-700",
              },
              {
                label: "æŒæ¡",
                value: 100,
                class:
                  "text-emerald-600 hover:bg-emerald-50 peer-checked:bg-emerald-100 peer-checked:text-emerald-700",
              },
            ],
          };
        },

        computed: {
          // æ ¹æ®ç­›é€‰æ¡ä»¶è¿‡æ»¤å•è¯åˆ—è¡¨
          filteredWordList() {
            if (this.filterType === "all") {
              return this.wordList;
            }

            const filterValue = {
              "not-learned": 0,
              vague: 50,
              mastered: 100,
            }[this.filterType];

            return this.wordList.filter((word) => {
              const mastery = this.wordMastery[word.id];
              // æœªæ ‡è®°çš„å•è¯æˆ–æœªå®šä¹‰çš„å•è¯
              if (mastery === undefined || mastery === null) {
                // æœªé€‰æ‹©çš„å•è¯æ ¹æ®ç­›é€‰æ¡ä»¶å†³å®šæ˜¯å¦æ˜¾ç¤º
                return this.filterType === "not-learned";
              }
              return mastery === filterValue;
            });
          },

          // è®¡ç®—æ€»é¡µæ•°
          totalPages() {
            return Math.ceil(this.filteredWordList.length / this.wordsPerPage);
          },

          // è®¡ç®—å·²å®Œæˆçš„å•è¯æ•°é‡ï¼ˆæ ‡è®°ä¸º"æ¨¡ç³Š"æˆ–"æŒæ¡"çš„å•è¯ï¼‰
          completedWordsCount() {
            return Object.values(this.wordMastery).filter(
              (mastery) => mastery === 50 || mastery === 100
            ).length;
          },

          // è®¡ç®—"ä¸ä¼š"çš„å•è¯æ•°é‡ï¼ˆæœªæ ‡è®°çš„å•è¯é»˜è®¤è§†ä¸º"ä¸ä¼š"ï¼‰
          notLearnedCount() {
            const markedAsNotLearned = Object.values(this.wordMastery).filter(
              (mastery) => mastery === 0
            ).length;
            const unmarked =
              this.wordList.length - Object.keys(this.wordMastery).length;
            return markedAsNotLearned + unmarked;
          },

          // è®¡ç®—"æ¨¡ç³Š"çš„å•è¯æ•°é‡
          vagueCount() {
            return Object.values(this.wordMastery).filter(
              (mastery) => mastery === 50
            ).length;
          },

          // è®¡ç®—"æŒæ¡"çš„å•è¯æ•°é‡
          masteredCount() {
            return Object.values(this.wordMastery).filter(
              (mastery) => mastery === 100
            ).length;
          },

          // è·å–å½“å‰é¡µçš„å•è¯åˆ—è¡¨
          currentPageWords() {
            const start = (this.currentPage - 1) * this.wordsPerPage;
            const end = start + this.wordsPerPage;
            return this.filteredWordList.slice(start, end);
          },

          // è®¡ç®—å¯è§çš„é¡µç æŒ‰é’®
          visiblePages() {
            const total = this.totalPages;
            const current = this.currentPage;
            const maxVisible = CONFIG.MAX_VISIBLE_PAGES;

            if (total <= maxVisible) {
              // å¦‚æœæ€»é¡µæ•°å°äºç­‰äºæœ€å¤§æ˜¾ç¤ºé¡µæ•°ï¼Œæ˜¾ç¤ºæ‰€æœ‰é¡µç 
              return Array.from({ length: total }, (_, i) => i + 1);
            }

            // è®¡ç®—èµ·å§‹å’Œç»“æŸé¡µç 
            let start = Math.max(1, current - Math.floor(maxVisible / 2));
            let end = Math.min(total, start + maxVisible - 1);

            // è°ƒæ•´èµ·å§‹é¡µç ï¼Œç¡®ä¿æ˜¾ç¤ºå›ºå®šæ•°é‡çš„é¡µç 
            if (end - start + 1 < maxVisible) {
              start = Math.max(1, end - maxVisible + 1);
            }

            return Array.from({ length: end - start + 1 }, (_, i) => start + i);
          },
        },

        methods: {
          /**
           * æ£€æŸ¥å•è¯çš„æŒæ¡ç¨‹åº¦
           * @param {String} wordId - å•è¯ID
           * @param {Number} mastery - æŒæ¡ç¨‹åº¦å€¼
           * @returns {Boolean} æ˜¯å¦åŒ¹é…
           */
          checkMastery(wordId, mastery) {
            const wordMasteryValue = this.wordMastery[wordId];
            // å¦‚æœå•è¯æœªæ ‡è®°ï¼ˆundefined æˆ– nullï¼‰ä¸”æ£€æŸ¥çš„æ˜¯"ä¸ä¼š"çŠ¶æ€ï¼Œè¿”å›true
            if (
              (wordMasteryValue === undefined || wordMasteryValue === null) &&
              mastery === 0
            ) {
              return true;
            }
            return wordMasteryValue === mastery;
          },

          /**
           * æ›´æ–°å•è¯æŒæ¡ç¨‹åº¦
           * @param {String} wordId - å•è¯ID
           * @param {Number} mastery - æŒæ¡ç¨‹åº¦å€¼
           */
          updateWordMastery(wordId, mastery) {
            if (mastery === 0) {
              // å¦‚æœé€‰æ‹©"ä¸ä¼š"ï¼Œåˆ™åˆ é™¤è¯¥å•è¯çš„çŠ¶æ€ï¼ˆé»˜è®¤ä¸ºä¸ä¼šï¼‰
              delete this.wordMastery[wordId];
            } else {
              // å…¶ä»–çŠ¶æ€ä¿å­˜
              this.wordMastery[wordId] = mastery;
            }
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveWordMastery();
          },

          /**
           * ä¿å­˜å•è¯æŒæ¡ç¨‹åº¦åˆ°æœ¬åœ°å­˜å‚¨ï¼ˆèŠ‚æµä¼˜åŒ–ï¼‰
           */
          saveWordMastery() {
            // ä½¿ç”¨èŠ‚æµï¼Œå‡å°‘å†™å…¥é¢‘ç‡
            if (this.saveTimer) {
              clearTimeout(this.saveTimer);
            }
            this.saveTimer = setTimeout(() => {
              try {
                const key = `wordMastery_${this.currentVocabularySet}`;
                localStorage.setItem(key, JSON.stringify(this.wordMastery));
              } catch (error) {
                console.error("ä¿å­˜æ•°æ®å¤±è´¥:", error);
              }
              this.saveTimer = null;
            }, 500);
          },

          /**
           * ä»æœ¬åœ°å­˜å‚¨åŠ è½½å•è¯æŒæ¡ç¨‹åº¦
           */
          loadWordMastery() {
            try {
              const key = `wordMastery_${this.currentVocabularySet}`;
              const saved = localStorage.getItem(key);
              if (saved) {
                this.wordMastery = JSON.parse(saved);
                console.log("âœ… å·²åŠ è½½ä¿å­˜çš„å•è¯çŠ¶æ€");
              } else {
                // å¦‚æœæœ¬åœ°æ²¡æœ‰ä¿å­˜çš„çŠ¶æ€ï¼Œåˆå§‹åŒ–ä¸ºç©ºå¯¹è±¡ï¼ˆæ‰€æœ‰å•è¯é»˜è®¤"ä¸ä¼š"ï¼‰
                this.wordMastery = {};
              }
            } catch (error) {
              console.error("åŠ è½½æ•°æ®å¤±è´¥:", error);
              this.wordMastery = {};
            }
          },

          /**
           * åˆ‡æ¢è¯æ±‡è¡¨
           */
          async switchVocabularySet() {
            // é‡ç½®é¡µç å’Œç­›é€‰
            this.currentPage = 1;
            this.filterType = "not-learned";
            // æ¸…ç©ºå½“å‰çŠ¶æ€
            this.wordMastery = {};
            // åŠ è½½æ–°è¯æ±‡è¡¨ï¼ˆç­‰å¾…å®Œæˆï¼‰
            await this.loadVocabulary();
            // åŠ è½½æ–°è¯æ±‡è¡¨çš„çŠ¶æ€
            this.loadWordMastery();
          },

          /**
           * è·³è½¬åˆ°æŒ‡å®šé¡µé¢
           * @param {Number} page - ç›®æ ‡é¡µç 
           */
          goToPage(page) {
            if (page >= 1 && page <= this.totalPages) {
              this.currentPage = page;
              // æ»šåŠ¨åˆ°é¡¶éƒ¨
              window.scrollTo({ top: 0, behavior: "smooth" });
            }
          },

          /**
           * è·å–å…¨å±€ç´¢å¼•ï¼ˆè·¨é¡µé¢çš„åºå·ï¼‰
           * @param {Number} index - å½“å‰é¡µé¢çš„ç´¢å¼•
           * @returns {Number} å…¨å±€ç´¢å¼•
           */
          getGlobalIndex(index) {
            return (this.currentPage - 1) * this.wordsPerPage + index + 1;
          },

          /**
           * æ’­æ”¾å•è¯å‘éŸ³
           * @param {String} word - è¦æ’­æ”¾çš„å•è¯
           */
          playWord(word) {
            if ("speechSynthesis" in window) {
              // å¦‚æœå½“å‰æ­£åœ¨æ’­æ”¾ï¼Œå°†æ–°å•è¯åŠ å…¥é˜Ÿåˆ—
              if (window.speechSynthesis.speaking && this.playingWord) {
                // å¦‚æœé˜Ÿåˆ—ä¸­æ²¡æœ‰ä¸”ä¸æ˜¯å½“å‰æ’­æ”¾çš„å•è¯ï¼ŒåŠ å…¥é˜Ÿåˆ—
                if (
                  !this.wordQueue.includes(word) &&
                  this.playingWord !== word
                ) {
                  this.wordQueue.push(word);
                }
                return;
              }

              // å¦‚æœæ²¡æœ‰æ­£åœ¨æ’­æ”¾ï¼Œå¼€å§‹æ’­æ”¾
              this.startPlaying(word);
            } else {
              // å¦‚æœæµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆAPIï¼Œæ˜¾ç¤ºæç¤º
              alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³æ’­æ”¾åŠŸèƒ½");
            }
          },

          /**
           * å¼€å§‹æ’­æ”¾å•è¯
           * @param {String} word - è¦æ’­æ”¾çš„å•è¯
           */
          startPlaying(word) {
            // è®¾ç½®å½“å‰æ’­æ”¾çš„å•è¯ï¼ˆæ˜¾ç¤ºæ’­æ”¾åŠ¨ç”»ï¼‰
            this.playingWord = word;

            // åˆ›å»ºæ–°çš„è¯­éŸ³åˆæˆ
            const utterance = new SpeechSynthesisUtterance(word);

            // è®¾ç½®å‘éŸ³å‚æ•°
            utterance.lang = "en-US"; // è®¾ç½®ä¸ºç¾å¼è‹±è¯­
            utterance.rate = 1.0; // æ’­æ”¾é€Ÿåº¦
            utterance.pitch = 1.0; // éŸ³è°ƒ
            utterance.volume = 1.0; // éŸ³é‡

            // æ’­æ”¾å®Œæˆåå¤„ç†
            utterance.onend = () => {
              if (this.playingWord === word) {
                this.playingWord = null;
                // æ’­æ”¾ä¸‹ä¸€ä¸ªé˜Ÿåˆ—ä¸­çš„å•è¯
                if (this.wordQueue.length > 0) {
                  const nextWord = this.wordQueue.shift();
                  this.$nextTick(() => {
                    this.startPlaying(nextWord);
                  });
                }
              }
            };

            // æ’­æ”¾å‡ºé”™æ—¶ä¹Ÿæ¸…é™¤çŠ¶æ€
            utterance.onerror = () => {
              this.playingWord = null;
              // å¦‚æœé˜Ÿåˆ—ä¸­è¿˜æœ‰å•è¯ï¼Œç»§ç»­æ’­æ”¾
              if (this.wordQueue.length > 0) {
                const nextWord = this.wordQueue.shift();
                this.$nextTick(() => {
                  this.startPlaying(nextWord);
                });
              }
            };

            // æ’­æ”¾éŸ³é¢‘
            window.speechSynthesis.speak(utterance);
          },

          /**
           * åˆå§‹åŒ–æ•°æ®åŠ è½½
           */
          async loadVocabulary() {
            try {
              // è·å–å½“å‰è¯æ±‡è¡¨çš„é…ç½®
              const currentSet = this.vocabularySets.find(
                (set) => set.value === this.currentVocabularySet
              );

              if (!currentSet || !currentSet.dataVar) {
                console.warn("å½“å‰è¯æ±‡è¡¨æœªé…ç½®æ•°æ®æº");
                this.wordList = this.getDefaultWords();
                return;
              }

              // æ ¹æ®dataVaråŠ è½½å¯¹åº”çš„æ•°æ®
              if (typeof window[currentSet.dataVar] === "undefined") {
                throw new Error(
                  `è¯æ±‡æ•°æ®æœªå®šä¹‰: ${currentSet.dataVar} for ${currentSet.label}`
                );
              }

              this.wordList = window[currentSet.dataVar];
              console.log(
                `âœ… æˆåŠŸåŠ è½½ ${this.wordList.length} ä¸ªå•è¯ (${currentSet.label})`
              );
              console.log("ğŸ“ è¯æ±‡åˆ—è¡¨ç¤ºä¾‹:", this.wordList.slice(0, 3));
            } catch (error) {
              console.error("âŒ åŠ è½½æ•°æ®å¤±è´¥:", error);
              this.wordList = this.getDefaultWords();
            } finally {
              this.loading = false;
            }
          },

          /**
           * è·å–é»˜è®¤ç¤ºä¾‹å•è¯
           * @returns {Array} ç¤ºä¾‹å•è¯æ•°ç»„
           */
          getDefaultWords() {
            return [];
          },

          /**
           * å¤„ç†æ»šåŠ¨äº‹ä»¶ï¼Œæ£€æµ‹æ˜¯å¦å¸é¡¶ï¼ˆå¸¦é˜²æŠ–ä¼˜åŒ–ï¼‰
           */
          handleScroll() {
            const header = document.querySelector(".sticky");
            if (header) {
              const rect = header.getBoundingClientRect();
              this.isSticky = rect.top <= 0; // å½“å¸é¡¶æ—¶
            }
          },

          /**
           * é˜²æŠ–å‡½æ•°
           */
          debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
              const later = () => {
                clearTimeout(timeout);
                func(...args);
              };
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
            };
          },
        },

        watch: {
          // ç›‘å¬ç­›é€‰ç±»å‹å˜åŒ–ï¼Œé‡ç½®é¡µç 
          filterType() {
            this.currentPage = 1;
          },
        },

        // ç»„ä»¶æŒ‚è½½ååŠ è½½æ•°æ®
        async mounted() {
          // å…ˆåˆå§‹åŒ–wordMastery
          this.wordMastery = {};
          // åŠ è½½è¯æ±‡æ•°æ®
          await this.loadVocabulary();
          // åŠ è½½ä¿å­˜çš„çŠ¶æ€ï¼ˆä¼šè¦†ç›–é»˜è®¤çš„ç©ºå¯¹è±¡ï¼‰
          this.loadWordMastery();
          // æ·»åŠ æ»šåŠ¨ç›‘å¬ï¼ˆä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ€§èƒ½ï¼‰
          this.debouncedHandleScroll = this.debounce(this.handleScroll, 10);
          window.addEventListener("scroll", this.debouncedHandleScroll);
        },

        // ç»„ä»¶å¸è½½å‰æ¸…ç†
        beforeUnmount() {
          if (this.debouncedHandleScroll) {
            window.removeEventListener("scroll", this.debouncedHandleScroll);
          }
          // æ¸…ç†ä¿å­˜è®¡æ—¶å™¨
          if (this.saveTimer) {
            clearTimeout(this.saveTimer);
          }
        },
      }).mount("#app");
    </script>
  </body>
</html>
